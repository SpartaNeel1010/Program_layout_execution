# Memory Layout and Organization

## SC8 CPU Memory Map

The SC8 CPU provides a 16-bit address space (64KB) organized as follows:

```
┌─────────────────────────────────────────┐
│  0xFFFF ┌───────────────────────────┐   │
│         │  Memory-Mapped I/O        │   │
│         │  (Console, Timer)         │   │
│  0xFF00 └───────────────────────────┘   │
│         ┌───────────────────────────┐   │
│         │                           │   │
│         │  Stack Area               │   │
│         │  (Grows Downward)         │   │
│         │  ↓                        │   │
│  0xFEFF │  <- SP (Initial)          │   │
│         │                           │   │
│         │                           │   │
│         │                           │   │
│         │  Free Space               │   │
│         │                           │   │
│         │                           │   │
│         │                           │   │
│  0x1000 └───────────────────────────┘   │
│         ┌───────────────────────────┐   │
│         │  Data Segment             │   │
│         │  (Variables, Constants)   │   │
│  0x0200 └───────────────────────────┘   │
│         ┌───────────────────────────┐   │
│         │  Code Segment             │   │
│         │  (Program Instructions)   │   │
│  0x0100 └───────────────────────────┘   │
│         ┌───────────────────────────┐   │
│         │  System Area              │   │
│         │  (Interrupt Vectors)      │   │
│  0x0000 └───────────────────────────┘   │
└─────────────────────────────────────────┘
```

## Memory Regions

### 1. System Area (0x0000 - 0x00FF)
- **Size**: 256 bytes
- **Purpose**: Reserved for system use and interrupt vectors
- **Usage**: Currently unused in our implementation (no interrupts)

### 2. Code Segment (0x0100 - 0x01FF)
- **Size**: Typically 256-4096 bytes
- **Purpose**: Stores program instructions
- **Content**: Machine code generated by the assembler
- **Access**: Read-only during execution

### 3. Data Segment (0x0200 - 0x0FFF)
- **Size**: Variable (up to 3584 bytes)
- **Purpose**: Static data, global variables, constants
- **Content**: Initialized and uninitialized data
- **Access**: Read-write

### 4. Stack Area (0x1000 - 0xFEFF)
- **Size**: ~60KB
- **Purpose**: Function calls, local variables, return addresses
- **Growth**: Downward (from high to low addresses)
- **Initial SP**: 0xFEFF
- **Access**: Read-write via PUSH/POP and stack pointer

### 5. Memory-Mapped I/O (0xFF00 - 0xFFFF)
- **Size**: 256 bytes
- **Purpose**: Hardware device access
- **Devices**:
  - `0xFF00`: Timer control
  - `0xFF01`: Console output (write character)
  - `0xFF02`: Console input (read character)
  - `0xFF03`: Timer value
  - `0xFF04-0xFFFF`: Reserved

## Executable Layout

When a program is loaded into memory, it follows this structure:

```
Address     Content                     Example (factorial.asm)
─────────────────────────────────────────────────────────────
0x0100      Program start              start: LOADI R7, 0xFF
0x0102      Initialization code        LOADI R6, 0xFE
0x0104      Main logic                 CALL print_header
...         ...                        ...
0x0150      Function: factorial        factorial: CMPI R0, 2
0x0152      ...                        JC base_case
...         ...                        ...
0x0180      Function: print_header     print_header: LOADI R5, 70
...         ...                        ...
```

### Instruction Sizes
- Single operand (SO): 1 byte (e.g., `PUSH R0`, `HALT`)
- Register-Immediate (RI): 2 bytes (e.g., `LOADI R0, 5`)
- Register-Register (RR): 2 bytes (e.g., `ADD R0, R1, R2`)
- Memory/Branch (MEM/BR): 3 bytes (e.g., `LOAD R0, [0x1000]`, `CALL label`)

## Stack Frame Structure

### Overview
Each function call creates a **stack frame** containing:
1. Return address (automatically pushed by `CALL`)
2. Saved registers
3. Parameters
4. Local variables

### Example: factorial(5) Call Chain

```
Initial State (before any calls):
SP -> 0xFEFF  [Empty]

After CALL factorial (with n=5):
      0xFEFD  [Return address low]
      0xFEFC  [Return address high]
SP -> 0xFEFB  [n=5] (pushed by function)

During recursive CALL factorial (with n=4):
      0xFEF9  [Return address low]
      0xFEF8  [Return address high]
SP -> 0xFEF7  [n=4] (pushed by function)
      0xFEF6  ...
      0xFEFB  [n=5] (from previous frame)
      0xFEFC  [Return address high]
      0xFEFD  [Return address low]

Maximum recursion depth (base case n=1):
      ...     [Multiple stack frames]
SP -> 0xFExx  [n=1]
      ...     [All previous frames]
```

### Stack Frame for factorial(n)

```
Higher Address
    │
    ├─────────────────────────────┐
    │ Return Address (High Byte)  │ <- Pushed by CALL instruction
    ├─────────────────────────────┤
    │ Return Address (Low Byte)   │ <- Pushed by CALL instruction
    ├─────────────────────────────┤
    │ Parameter n                 │ <- Pushed by function prologue
    ├─────────────────────────────┤
    │ Saved R1 (if needed)        │ <- Saved by function
    ├─────────────────────────────┤
    │ Local variables (if any)    │
    ├─────────────────────────────┤ <- SP points here
    │                             │
Lower Address
```

## Stack Operations

### PUSH Operation
```
PUSH R0:
1. SP = SP - 1
2. Memory[SP] = R0
```

### POP Operation
```
POP R0:
1. R0 = Memory[SP]
2. SP = SP + 1
```

### CALL Operation
```
CALL address:
1. Push PC_low onto stack
2. Push PC_high onto stack
3. PC = address
```

### RET Operation
```
RET:
1. Pop PC_high from stack
2. Pop PC_low from stack
3. PC = (PC_high << 8) | PC_low
```

## Data Segment Organization

For programs that need static data:

```
Address     Purpose                  Size
─────────────────────────────────────────
0x0200      String: "Hello"          6 bytes
0x0206      Array: [1,2,3,4,5]       5 bytes
0x020B      Variable: counter        1 byte
0x020C      Variable: result         1 byte
...         ...                      ...
```

## Memory Access Patterns

### 1. Code Fetch
```assembly
; CPU fetches instructions from code segment
PC = 0x0100  -> Fetch instruction at 0x0100
PC = 0x0102  -> Fetch next instruction
```

### 2. Data Access
```assembly
; Load from data segment
LOAD R0, [0x0200]    ; Read data at 0x0200

; Store to data segment
STORE R0, [0x0200]   ; Write R0 to 0x0200
```

### 3. Stack Access
```assembly
; Push/Pop operations
PUSH R0              ; Write to [SP-1], decrement SP
POP R0               ; Read from [SP], increment SP
```

### 4. I/O Access
```assembly
; Memory-mapped I/O
STORE R0, [0xFF01]   ; Write character to console
LOAD R0, [0xFF02]    ; Read character from console
```

## Memory Safety Considerations

### Stack Overflow
- **Problem**: Deep recursion can exhaust stack space
- **Symptom**: SP decreases below data segment
- **Example**: factorial(100) would create 100 stack frames
- **Prevention**: Limit recursion depth, use iteration when possible

### Stack Collision
```
Code Segment:     0x0100 - 0x01FF
Data Segment:     0x0200 - 0x0FFF
Stack Area:       0x1000 - 0xFEFF

If Stack grows beyond 0x1000:
┌────────────────────────────────┐
│ Data Segment   [0x0200-0x0FFF] │
├────────────────────────────────┤ <- Collision point!
│ Stack Area     [SP moves down] │
└────────────────────────────────┘
```

### Optimal Stack Depth Calculation

For factorial(n):
- Each call uses ~4 bytes (return address + saved n)
- Stack space: ~60KB = 60,000 bytes
- Max safe recursion: 60,000 / 4 = 15,000 levels
- Practical limit: n=255 (8-bit value limit)

## Example: factorial(3) Memory Trace

### Initial State
```
PC: 0x0100
SP: 0xFEFF
R0: 3
Code at 0x0100: CALL factorial
```

### Step 1: CALL factorial (n=3)
```
Stack:
0xFEFD: [PC_low of return address]
0xFEFC: [PC_high of return address]
SP: 0xFEFC
PC: 0x0150 (factorial function start)
R0: 3
```

### Step 2: Inside factorial(3)
```
Code: CMPI R0, 2  -> Compare R0 with 2
      Result: R0 > 2, not carry
Code: JC base_case -> Not taken
Code: PUSH R0      -> Save n=3

Stack:
0xFEFB: [3] <- n
0xFEFC: [PC_high]
0xFEFD: [PC_low]
SP: 0xFEFB
```

### Step 3: Recursive CALL factorial(2)
```
Code: DEC R0       -> R0 = 2
Code: CALL factorial

Stack:
0xFEF9: [PC_low]
0xFEF8: [PC_high]
0xFEF7: <- SP
...
0xFEFB: [3]        (saved from first call)
```

### Step 4: Recursive CALL factorial(1)
```
Stack:
0xFEF5: [PC_low]
0xFEF4: [PC_high]
0xFEF3: <- SP
...
0xFEF7: [2]        (from second call)
0xFEFB: [3]        (from first call)
```

### Step 5: Base Case Reached (n=1)
```
Code: CMPI R0, 2  -> R0 = 1, carry set
Code: JC base_case -> Jump taken
Code: LOADI R0, 1 -> R0 = 1
Code: RET

R0: 1 (return value)
SP begins unwinding...
```

### Step 6-7: Unwinding Stack
As each RET executes, the stack unwinds, and multiplication occurs at each level:
- factorial(1) returns 1
- factorial(2) returns 2 × 1 = 2
- factorial(3) returns 3 × 2 = 6

### Final State
```
PC: [after original CALL]
SP: 0xFEFF (restored)
R0: 6 (factorial(3))
Stack: Empty
```

## Performance Characteristics

### Memory Usage
- **Code**: ~200-300 bytes per program
- **Stack**: 4 bytes per recursion level
- **Data**: Minimal (mostly registers)

### Memory Bandwidth
- 8-bit data bus = 1 byte per memory access
- Typical instruction = 1-3 memory reads (fetch)
- Stack operations = 1-2 memory accesses (push/pop)

### Optimization Strategies
1. **Use registers** instead of memory when possible
2. **Minimize stack usage** by avoiding unnecessary saves
3. **Keep code compact** to improve cache locality (if CPU had cache)
4. **Avoid deep recursion** to prevent stack overflow

